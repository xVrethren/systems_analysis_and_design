# Chapter 1
## Introduction to the Course
---
### 1. *Have a high-level understanding of what a systems analyst is and does. What is their primary goal? What types of skills are important for a systems analyst to have?*

---
**Systems Analyst Overview**:
A systems analyst is a professional who studies the existing systems and procedures of an organization to design solutions that help the organization operate more efficiently and effectively. They act as a bridge between the business side and the IT side of an organization.

**Primary Goal**:
The primary goal of a systems analyst is to understand business processes and user needs, and then design or modify systems to meet those needs while ensuring they're efficient, effective, and technically feasible.

**Key Skills**:
- **Analytical Skills**: Ability to dissect complex problems, understand system requirements, and devise effective solutions.

- **Technical Proficiency**: Familiarity with software, hardware, databases, and other technological tools and processes is essential.
- **Communication Skills**:
Must be able to convey technical concepts to non-technical stakeholders and understand their requirements and feedback.
- **Problem-Solving Skills**:
Ability to identify issues within a system or process and come up with effective solutions.
- **Project Management**:
Organizing tasks, managing time, understanding project phases, and ensuring projects stay on track.
- **Business Acumen**:
Understanding of the business domain ensures the systems designed align with the organization's goals and strategies.
- **Teamwork and Collaboration**:
Systems analysts often work with various departments and teams, so being able to collaborate and work well with others is crucial.
- **Attention to Detail**:
Ensuring all specifications are met and that systems are free from critical errors requires a keen eye for detail.

---
### 2.  *Be able to discuss why systems analysis and design is important to the development of systems.*

---
* 1. **Foundation for System Development**:
Systems analysis provides a clear understanding of business needs and requirements. The design phase then translates these requirements into specifications that will guide system development. Without this foundational step, the resulting system might not align with the business's objectives or user needs.
* 2. . **Cost-Efficiency**:
Addressing problems during the analysis and design phases is considerably cheaper than rectifying them after the system has been developed. By pinpointing and mitigating potential issues early on, organizations can save significant amounts of time, money, and resources.
* 3. **User Satisfaction**:
The process of systems analysis involves gathering requirements directly from stakeholders and end-users. This ensures that the final system meets their needs and expectations, leading to a higher level of user satisfaction and system adoption.
* 4. **Risk Reduction**:
A thorough systems analysis and design process can identify potential risks and challenges. By addressing these proactively, organizations can reduce the likelihood of project overruns, system failures, or unmet user requirements.

---

### 3. *Know what the Systems Development Life Cycle (SDLC) is and be able to describe the objective of each process (that is, project initiation, project management, analysis, design implementation).*

---
**Systems Development Life Cycle (SDLC)**:
The SDLC is a structured methodology used in the development of information systems. It consists of a series of phases, each with specific objectives, to ensure the successful development and deployment of a system.
- Project Initiation
  - **Objective**: Establish the need and viability of a new system.
  - Identify potential system enhancements or new systems required.
  - Secure initial resources and stakeholder buy-in.
  - Define the project's scope and objectives.

- Project Management
  - **Objective**: Plan, execute, monitor, and close the project to ensure it stays on track.
  - Define project tasks, timelines, and resources.
  - Monitor progress and handle any deviations or risks.
  - Ensure effective communication among stakeholders.

- Analysis
  - **Objective**: Understand and document the business requirements of the system.
  - Gather requirements from stakeholders and end-users.
  - Analyze current systems and processes (if any exist).
  - Define functional and non-functional requirements for the new system.

- Design
  - **Objective**: Develop the technical specifications for the system based on the analysis.
  - Design system architecture and database structures.
  - Create user interface mockups and workflows.
  - Define system interactions and integrations with other systems.

- Implementation
  - **Objective**: Build, test, and deploy the system.
  - Develop the system based on the design specifications.
  - Conduct unit, integration, and system testing.
  - Deploy the system in the target environment and train end-users.

---

## SCRUM
---
### 1. *What is SCRUM? Be able to describe the SCRUM methodology very well (read the SCRUM guide).*

---
SCRUM is an agile framework used primarily for product development, especially software. It emphasizes collaboration, adaptability, and iterative progress to maximize the value of the product being developed.
* Key Concepts:
  - **Iterations (Sprints)**
    - SCRUM breaks the product development cycle into fixed-length iterations called "Sprints," typically lasting 2. -4 weeks.
    - At the end of each sprint, a potentially shippable product increment is delivered.
  * **SCRUM Events**
    - **Sprint Planning**: At the beginning of a sprint, the team plans the work for the upcoming iteration.
    - **Daily Scrum (or Stand-Up)**: A short daily meeting where the development team discusses progress and any obstacles.
    - **Sprint Review**: At the end of the sprint, the team demonstrates the completed work to stakeholders.
    - **Sprint Retrospective**: The team reviews the past sprint and discusses improvements for the next one.
  * **SCRUM Roles**
    - **Product Owner**: Represents the customer's interests and prioritizes the product backlog.
    - **Scrum Master**: Ensures that the team follows the SCRUM process, removes impediments, and facilitates SCRUM events.
    - **Development Team**: A cross-functional group responsible for delivering the product increments.
  * **SCRUM Artifacts**
    - **Product Backlog**: A prioritized list of features, enhancements, and fixes for the product.
    - **Sprint Backlog**: A list of tasks the team commits to completing during a given sprint.
    - **Potentially Releasable Product Increment**: The set of backlog items completed during a sprint combined with the work from previous sprints.
  * **Three Pillars of SCRUM**
    - **Transparency**: Ensuring that every aspect of the process is visible to those responsible for the outcome.
    - **Inspection**: Regularly checking the various SCRUM artifacts and progress towards a sprint goal to detect undesirable variances.
    - **Adaptation**: Adjusting the process if any aspect deviates outside acceptable limits or if the product will be unacceptable.
  * **SCRUM Values**
    - **Courage**: Standing up for what's right and working on tough problems.
    - **Focus**: Concentrating on the work of the sprint and the goals of the team.
    - **Commitment**: Being personally committed to achieving the goals of the SCRUM team.
    - **Respect**: Respecting each other as capable, independent people.
    - **Openness**: Being open about challenges and how to deal with them.

---
## Why & When Agile

---
### 1. *Be able to describe agile development in general (philosophy, basic principles, etc) and its advantages and disadvantages. What does agile enable us to do(that is, why use agile?)?*

---


#### Agile Development: Overview
Agile development is an iterative approach to software development and project management that emphasizes collaboration, customer feedback, and rapid release of prototypes or working products. It contrasts with traditional "waterfall" methods, which involve a linear sequence of phases like requirements gathering, design, implementation, testing, and deployment.

#### Philosophy and Basic Principles:
- **Iterative Development**: Agile favors small, incremental changes and frequent releases.
- **Customer Collaboration**: Active user involvement and feedback are crucial.
- **Responding to Change**: Agile values adapting to change over following a strict plan.
- **Working Software**: Delivering functional software frequently is a top priority.
- **Cross-functional Teams**: Teams usually consist of members with varied skills and are self-organizing.
- **Simplicity**: Do what's necessary and no more. Prioritize work that adds value.
- **Continuous Improvement**: Teams regularly reflect on their performance and adjust accordingly.

#### Advantages:
- **Flexibility**: Agile can quickly adapt to changes in requirements or market conditions.
- **Customer Satisfaction**: Continuous feedback ensures that the product aligns with customer needs.
- **Reduced Risks**: Frequent releases allow for early detection of issues or mismatches with requirements.
- **Improved Quality**: Regular reviews and iterations can lead to a better end product.
- **Enhanced Collaboration**: Daily meetings and feedback loops promote communication and collaboration.

#### Disadvantages:
- **Requires Experienced Team Members**: Agile requires team members to be familiar with the methodology to be effective.
- **Potential Scope Creep**: Without careful management, the scope of the project can expand.
- **Not Always Suitable**: Some projects, especially those with well-defined and unchanging requirements, might not benefit from an agile approach.
- **Potential for Burnout**: The fast-paced nature of agile can be stressful for some teams.

#### Why Use Agile?
Agile enables organizations to:
- **Adapt to Change**: Quickly pivot in response to changing market conditions or user feedback.
- **Deliver Value Faster**: By focusing on the most important features first, value is delivered to users more quickly.
- **Collaborate Better**: Enhanced communication among team members and with stakeholders.
- **Reduce Uncertainties**: By breaking the project into smaller chunks and tackling them iteratively, uncertainties are addressed earlier.

---

### 2.  *Be able to discuss which conditions would favor predictive vs. agile approaches to the SDLC (e.g., see the Cynefin framework, HBR article on agile).*

---

#### Predictive (Waterfall) vs. Agile Approaches: Overview
The choice between predictive and agile approaches in the SDLC often depends on the nature of the project, the environment, and the specific requirements. While both methodologies have their advantages, they are suited to different contexts.

#### Predictive (Waterfall) Approach:
The predictive approach is sequential and linear, where each phase of the project follows in order. This method works best when:
- **Clear Requirements**: The project's requirements are well-understood and stable.
- **Stable Environment**: There's little change expected in the market or technology during the project's duration.
- **Low Uncertainty**: The project's goals, technology, and methods are all well-defined from the start.
- **Risk Management**: Projects where risks need to be identified and managed upfront.
- **Regulated Environments**: Projects that require rigorous documentation and adherence to standards (e.g., aerospace or healthcare).

#### Agile Approach:
Agile is iterative and allows for changes throughout the development process. It is particularly advantageous when:
- **Uncertain Requirements**: The exact requirements are not clear or are expected to evolve.
- **Dynamic Environment**: Rapid changes in market dynamics, technology, or user feedback are anticipated.
- **High Collaboration**: Active involvement and feedback from stakeholders are desired.
- **Frequent Deliverables**: The need to deliver working software or prototypes frequently.
- **Complex Solutions**: Projects where solutions emerge through the collaborative effort of self-organizing teams.

#### Cynefin Framework Insights:
The Cynefin framework, developed by Dave Snowden, offers a way to visualize problems and determine how best to approach them. It categorizes problems into five domains: Clear, Complicated, Complex, Chaotic, and Disorder.
- **Clear**: Predictable problems with known solutions. Predictive approaches work well here.
- **Complicated**: Problems that require expert analysis. Predictive methods can be suitable.
- **Complex**: Problems where outcomes are unpredictable. Agile methods shine here as they allow for experimentation.
- **Chaotic**: Urgent problems with no clear solutions. Agile can be beneficial for rapid responses.
- **Disorder**: Problems that are not understood. Requires sense-making to decide the approach.

#### HBR Insights on Agile:
Harvard Business Review articles on agile emphasize its value in fostering innovation, responding to market shifts, and enhancing collaboration. Agile is especially beneficial in uncertain environments where adaptability and speed are paramount.

---

### 3. *Understand the advantages and drawbacks of the waterfall model. When would you use this?*

---
#### Waterfall Model: Overview
The Waterfall model is one of the earliest methodologies used in software development. It is a linear and sequential approach where each phase of the project must be completed before the next phase begins.

#### Advantages of the Waterfall Model:
- **Clear Structure**: Each phase has specific deliverables and a review process, making it easy to understand and manage.
- **Documentation**: Emphasis on documentation at each stage ensures that there's a thorough record of the project's evolution.
- **Predictability**: Timelines and requirements are defined upfront, which can aid in budgeting and scheduling.
- **Minimized Overhead**: Without the need for frequent iterations or backtracking, administrative overhead can be reduced.
- **Easy to Manage**: Due to its linear nature, it's simpler to manage as each phase has a defined start and end point.

#### Drawbacks of the Waterfall Model:
- **Inflexibility**: Once a phase is completed, it's difficult to go back and make changes without disrupting the whole process.
- **Late Feedback**: Clients or end-users only see the product at the very end, which can lead to costly changes if it doesn't meet expectations.
- **High Risk**: If errors are found late in the process, they can be expensive and time-consuming to fix.
- **Not Suitable for Complex and Object-Oriented Projects**: The model struggles with projects where requirements evolve.
- **Long Delays**: If a phase is delayed, it can hold up subsequent phases, leading to extended project timelines.

#### When to Use the Waterfall Model:
- **Well-Defined Projects**: Projects where requirements are clear and unlikely to change.
- **Short Projects**: Projects of short duration where requirements gathering is straightforward.
- **Stable Environment**: Environments where technological and market dynamics are stable.
- **Experienced Teams**: Teams that are experienced with the Waterfall approach and have had success with it in the past.

---

## Project Initiation - Visioning

### 1. *Describe the Agile Development Lifecycle (Project Initiation, Release Planning, etc.) and the purpose of each step*

---

#### Agile Development Lifecycle: Overview

The Agile Development Lifecycle is a flexible and iterative approach to software development, characterized by short development cycles or "sprints." Unlike the Waterfall model, Agile allows for regular feedback and adjustments throughout the development process.

#### 1. **Project Initiation**:

- **Purpose**: To define the project's vision, scope, and stakeholders. It sets the direction and goals for the project.
- **Key Activities**: Defining the product vision, identifying stakeholders, and creating the product roadmap.

#### 2.  **Release Planning**:

- **Purpose**: To decide on the features and functionalities to be developed in the upcoming release.
- **Key Activities**: Prioritizing features, estimating effort, and setting a timeline for the release.

#### 3. **Sprint Planning**:

- **Purpose**: To decide on the specific set of tasks to be completed in the upcoming sprint.
- **Key Activities**: Breaking down features into tasks, estimating effort for each task, and defining the sprint goal.

#### 4. **Iteration (Sprint)**:

- **Purpose**: To develop, test, and integrate the features or tasks decided upon in the sprint planning.
- **Key Activities**: Coding, unit testing, integration, and regular stand-up meetings to discuss progress and blockers.

#### 5. **Daily Stand-Up (Daily Scrum)**:

- **Purpose**: To synchronize the team's activities and address any challenges.
- **Key Activities**: Each team member shares what they did the previous day, what they plan to do today, and any obstacles they face.

#### 6. **Iteration Review**:

- **Purpose**: To demonstrate the work completed during the sprint to stakeholders and gather feedback.
- **Key Activities**: Demonstrating features, gathering feedback, and adjusting priorities based on feedback.

#### 7. **Retrospective**:

- **Purpose**: To reflect on the sprint and identify areas of improvement for the next one.
- **Key Activities**: Discussing what went well, what could be improved, and creating a plan for implementing improvements in the next sprint.

#### 8. **Release**:

- **Purpose**: To deliver a potentially shippable product increment to the user.
- **Key Activities**: Final testing, bug fixing, and deploying the product.

---

### 2. *Describe the activities that are involved in Project Initiation.*

---

#### Activities in Project Initiation:

1. **Developing the Project Vision**:
    - **Purpose**: To establish a clear idea of what the project aims to achieve.
    - **Activities**: Identifying key project objectives, stakeholders, expected benefits, and potential risks.

2. **Identifying the Product Owner**:
    - **Purpose**: To ensure there is a clear decision-maker who can provide direction and prioritize work.
    - **Activities**: Selecting a person responsible for maximizing the value of the product and representing the interests of stakeholders.

3. **Creating the Product Roadmap**:
    - **Purpose**: To provide a high-level view of the product’s journey.
    - **Activities**: Outlining the anticipated development path, major features, and release milestones.

4. **Defining the Product Backlog**:
    - **Purpose**: To maintain a prioritized list of features, enhancements, and fixes to be developed.
    - **Activities**: Identifying and prioritizing user stories, tasks, and potential improvements based on business value and user needs.

5. **Forming the Agile Team**:
    - **Purpose**: To assemble a cross-functional group that can deliver value.
    - **Activities**: Bringing together individuals with the necessary skills and defining roles (e.g., Scrum Master, Development Team).

6. **Establishing the Project Environment**:
    - **Purpose**: To create a workspace conducive to collaboration and efficient work.
    - **Activities**: Setting up physical/virtual workspaces, tools, and establishing communication and collaboration practices.

7. **Identifying Stakeholders**:
    - **Purpose**: To understand who has an interest in the project and establish communication.
    - **Activities**: Identifying individuals or organizations impacted by the project and defining a communication plan.

8. **Developing the Release Plan**:
    - **Purpose**: To plan the next set of product iterations.
    - **Activities**: Identifying the features to be developed in the next release, estimating effort, and defining release goals.

---

### 3. *What is the System Vision document? What is its purpose? What are its basic components? Be able to correctly identify and/or provide examples of each component of a standard system vision document. Make sure you can properly articulate the difference between business needs, system capabilities (i.e. system functionality), and business benefits (and give examples of each). Know what conditions of satisfaction are.*

---

#### Overview:

The System Vision document provides a high-level view of the intended project and its value proposition. It serves as a bridge between the initial idea and detailed requirements, giving stakeholders a clear understanding of the project's direction.

#### Purpose:

- **Alignment**: Ensures all stakeholders have a common understanding of the project's goals.
- **Guidance**: Provides a reference point for future decisions.
- **Communication**: Helps convey the project's vision to potential users, stakeholders, and the development team.

#### Basic Components:

1. **Introduction**: A brief overview of the document and its purpose.
2. **Business Needs**:
    - **Definition**: The problems or opportunities the system addresses.
    - **Example**: "The company lacks a centralized system to manage customer queries, leading to delayed responses."
3. **System Capabilities (System Functionality)**:
    - **Definition**: The major features or functions the system will provide to address the business needs.
    - **Example**: "A customer relationship management (CRM) module that streamlines query tracking and response."
4. **Business Benefits**:
    - **Definition**: The advantages or value the business will gain from the system.
    - **Example**: "A 30% reduction in response time to customer queries, leading to increased customer satisfaction."
5. **Stakeholders**: A list of individuals, groups, or entities with an interest in the project.
6. **System Vision Statement**: A concise description of the system's purpose and its primary objectives.
7. **Conditions of Satisfaction**:
    - **Definition**: The criteria that will determine the successful completion of the project.
    - **Example**: "The CRM system must support 10,000 concurrent users and integrate seamlessly with existing inventory systems."

#### Articulating the Differences:

- **Business Needs**: These are the challenges or opportunities that the system aims to address. They arise from gaps or inefficiencies in the current system or process.
    - *Example*: "The need to process customer orders faster."

- **System Capabilities (System Functionality)**: These are the features or functionalities the system will offer to fulfill the identified business needs.
    - *Example*: "An automated order processing feature."

- **Business Benefits**: These are the tangible and intangible gains the business expects as a result of implementing the system.
    - *Example*: "A 50% reduction in order processing time, leading to higher sales and improved customer satisfaction."

#### Conditions of Satisfaction:

Conditions of satisfaction are clear, specific criteria that define what constitutes a successful project outcome. They provide a benchmark against which the final product can be evaluated to determine if it meets the project's objectives.

---

### 4. *Know how to develop the Design the Box – what goes in the front of the box and what goes on the back of the box. Also know how to write the vision statement using Geoffrey Moore’s Elevator Pitch method*

--- 

#### Design the Box:

"Design the Box" is an innovative exercise used in product development and agile workshops to help teams visualize the final product. By imagining how the product would look if it were packaged in a box, teams can focus on key features, benefits, and the overall value proposition.

**Front of the Box**:
1. **Product Name**: A catchy title for the product.
2. **Main Image**: A visual representation of the product or its primary use case.
3. **Key Features**: A list of the top 3-5 features of the product.
4. **Slogan or Tagline**: A memorable phrase that conveys the essence of the product.

**Back of the Box**:
1. **Detailed Description**: An in-depth description of the product and its capabilities.
2. **List of Features**: A comprehensive list of all product features.
3. **User Testimonials**: Positive feedback or quotes from beta testers or stakeholders.
4. **System Requirements**: Technical or environmental requirements for using the product (common for software or tech products).
5. **Contact Information**: Details for customer support or further inquiries.

#### Geoffrey Moore’s Elevator Pitch Method:

Crafting a compelling vision statement using Geoffrey Moore's method involves succinctly summarizing the essence of a product or idea. The formula is:

```
For [target customer]
Who [statement of the need or opportunity]
The [product name] is a [product category]
That [key benefit, compelling reason to buy]
Unlike [primary competitive alternative]
Our product [statement of primary differentiation]
```

**Example**:

```
For busy professionals
Who need a quick and healthy meal option
The "QuickMeal" is a meal prep service
That delivers nutritious, ready-to-eat meals to your doorstep.
Unlike traditional fast food options
Our product offers a variety of gourmet dishes crafted by expert chefs using organic ingredients.
```

Using this method, teams can quickly and effectively communicate the unique value proposition of their product or service.

---

### 5. *Know what feasibility analysis is, its primary purpose, and what is examined in each of its components (technical, economic, organizational, schedule and resource feasibility). Understand the relationship between the feasibility analyses you perform and project risks. What can you do to mitigate risk identified in each type of feasibility analysis? Given a short scenario be able to identify and assess technical, economic and/or organizational feasibility*

---

#### Overview:

Feasibility analysis is a preliminary evaluation of a proposed project or system to determine its viability. It helps stakeholders decide whether to proceed with the project, modify its scope, or abandon it altogether.

#### Primary Purpose:

- **Decision Making**: To provide a basis for making informed decisions about the project.
- **Risk Identification**: To identify potential risks and challenges early in the project lifecycle.

#### Components of Feasibility Analysis:

1. **Technical Feasibility**:
    - **Examination**: Determines whether the necessary technology and software are available or can be developed to meet the project's requirements.
    - **Risks**: Lack of technical expertise, evolving technology standards, software incompatibility.
    - **Mitigation**: Training, hiring experts, using established platforms, prototyping.

2. **Economic Feasibility (Cost-Benefit Analysis)**:
    - **Examination**: Assesses whether the expected benefits of the project outweigh the estimated costs.
    - **Risks**: Cost overruns, underestimated costs, overestimated benefits.
    - **Mitigation**: Detailed budgeting, contingency funds, regular financial reviews.

3. **Organizational Feasibility**:
    - **Examination**: Evaluates whether the project aligns with the organization's strategic goals and cultural dynamics.
    - **Risks**: Resistance to change, misalignment with business strategy.
    - **Mitigation**: Stakeholder engagement, change management strategies, clear communication.

4. **Schedule Feasibility**:
    - **Examination**: Determines whether the project can be completed within the proposed timeline.
    - **Risks**: Delays, dependency conflicts, underestimated time requirements.
    - **Mitigation**: Buffer periods, phased approaches, clear milestones.

5. **Resource Feasibility**:
    - **Examination**: Assesses whether the necessary resources (human, material, financial) are available.
    - **Risks**: Resource constraints, over-allocation, unavailability.
    - **Mitigation**: Resource leveling, outsourcing, prioritization.

#### Relationship between Feasibility Analyses and Project Risks:

Feasibility analysis is intrinsically tied to risk management. By evaluating a project's feasibility across multiple dimensions, potential risks are identified early. Addressing these risks at the outset can lead to more accurate planning and better project outcomes.

#### Assessing Feasibility from a Scenario:

Given a scenario, one can identify:

- **Technical Feasibility** by examining the technical challenges, tools, platforms, and expertise required.
- **Economic Feasibility** by comparing the projected costs against the expected benefits or returns.
- **Organizational Feasibility** by assessing how well the project aligns with organizational goals, values, and culture.

---
---
---

# Chapter 2 - Investigating System Requirements

## 1. *Be able to describe the Systems Analysis activities: gather information, define requirements (through various types of models), prioritize requirements, develop user interface dialogs, evaluate requirements with users. Know what each activity is and why it is important.*

---

#### Systems Analysis Activities:

Systems Analysis is a process that delves deep into a system's operations to identify its needs and then design a solution. Here are the primary activities involved:

1. **Gather Information**:
    - **What**: The process of collecting data about the system, its operations, its users, and its interactions.
    - **Why**: To have a foundational understanding of the existing system, its strengths, weaknesses, and areas of improvement.

2. **Define Requirements**:
    - **What**: Identifying what the new system should do. This is often done using various types of models like data flow diagrams, use case diagrams, and entity-relationship diagrams.
    - **Why**: To ensure that the new system meets the needs of its users and the goals of the organization.

3. **Prioritize Requirements**:
    - **What**: Ranking requirements based on their importance, potential impact, and feasibility.
    - **Why**: Not all requirements can be implemented at once, so prioritizing helps in focusing on the most critical needs first.

4. **Develop User Interface Dialogs**:
    - **What**: Designing the interaction between the user and the system, often using wireframes or mockups.
    - **Why**: A well-designed user interface enhances user experience and ensures that users can efficiently complete their tasks.

5. **Evaluate Requirements with Users**:
    - **What**: Reviewing the defined requirements with actual users to ensure they align with their needs.
    - **Why**: To confirm that the system being designed will be useful, usable, and meet the expectations of its users.

---

## 2. *Understand what functional and nonfunctional requirements are. A good framework for this is FURPS+. Know the various types of non-functional requirements. Be able to give examples of each. Be able to correctly identify whether items found in a list of requirements are considered functional or nonfunctional (and if nonfunctional, what type of nonfunctional requirement).*

---

#### Functional vs. Nonfunctional Requirements:

- **Functional Requirements**:
    - **Definition**: Describe what a system is supposed to accomplish. They are statements of services the system should provide.
    - **Example**: "The system must allow users to log in using a username and password."

- **Nonfunctional Requirements**:
    - **Definition**: Describe how the system performs its functions. They set the behavior of the system.
    - **Example**: "The system must respond to user login requests within 2 seconds."

#### FURPS+ Framework:

FURPS+ is an acronym representing different categories of nonfunctional requirements:

- **F**: Functionality (Functional Requirements)
- **U**: Usability
    - Example: "The system must provide an intuitive user interface."
- **R**: Reliability
    - Example: "The system must have 99.9% uptime."
- **P**: Performance
    - Example: "The system must support 10,000 concurrent users."
- **S**: Supportability (or Scalability)
    - Example: "The system must be scalable to support future user growth."

The **"+"** in FURPS+ denotes additional nonfunctional categories including:
- **Design constraints**: Restrictions on system architecture or design.
- **Implementation requirements**: Standards or processes to follow during development.
- **Interface requirements**: How the system will interact with other systems or software.
- **Physical requirements**: Hardware or physical specifications.

#### Types of Nonfunctional Requirements:

1. **Usability**: Concerned with user experience and interface design.
2. **Reliability**: Relates to the system's stability and uptime.
3. **Performance**: Deals with response times and system capacity.
4. **Supportability/Scalability**: Concerned with future growth and system evolution.
5. **Security**: Relates to data protection and user privacy.
6. **Compliance**: Ensures the system adheres to regulations and standards.

#### Identifying Requirements:

Given a list of requirements, one can categorize them as:

- **Functional**: If they describe a specific function or feature of the system.
- **Nonfunctional**: If they describe the quality, behavior, or manner in which the system implements its functions. Further, based on the specifics, one can classify nonfunctional requirements under usability, reliability, performance, etc.

---

## 3. *Know the various types of information gathering techniques.*

---

#### Information Gathering Techniques:

1. **Interviews**:
    - **Description**: One-on-one discussions with stakeholders, users, or experts to gather detailed information.
    - **Advantages**: Allows for deep dives into specific topics and clarifications.
    - **Limitations**: Can be time-consuming; the quality of information may vary based on the interviewee.

2. **Questionnaires and Surveys**:
    - **Description**: Structured sets of questions distributed to a larger audience.
    - **Advantages**: Can reach a large number of respondents; standardized responses.
    - **Limitations**: Limited depth; relies on the quality of the questions.

3. **Observation (Job Shadowing)**:
    - **Description**: Watching users or employees perform their tasks to understand the process.
    - **Advantages**: Direct insight into actual practices and issues.
    - **Limitations**: Might not capture infrequent issues; users might alter behavior when observed.

4. **Document Analysis**:
    - **Description**: Review of existing documentation, such as manuals, reports, and system specs.
    - **Advantages**: Can provide a historical and contextual perspective.
    - **Limitations**: Existing documentation might be outdated or incomplete.

5. **Workshops**:
    - **Description**: Structured group sessions with stakeholders to gather information collaboratively.
    - **Advantages**: Multiple perspectives; promotes consensus.
    - **Limitations**: Requires effective facilitation; potential for dominant voices to overshadow others.

6. **Brainstorming**:
    - **Description**: Group activity to generate a large number of ideas or solutions.
    - **Advantages**: Encourages creativity; can uncover unexpected insights.
    - **Limitations**: Requires synthesis and prioritization after brainstorming.

7. **Prototyping**:
    - **Description**: Creating a preliminary version of the system to gather feedback.
    - **Advantages**: Provides a tangible or visual way to gather requirements; helps in clarifying complex functionalities.
    - **Limitations**: Can be time-consuming; potential for scope creep.

8. **Use Cases and User Stories**:
    - **Description**: Descriptive methods to capture system interactions from a user's perspective.
    - **Advantages**: Focuses on user needs and objectives; easy to understand.
    - **Limitations**: Might not capture all system functionalities.

9. **Focus Groups**:
    - **Description**: Group discussions led by a moderator to gather insights on specific topics.
    - **Advantages**: Deep dive into specific areas; diverse perspectives.
    - **Limitations**: Can be influenced by group dynamics; requires skilled moderation.

---
---
---

# Chapter 3 - Use Cases

### 1. *Know what a use case is – be able to define and be able to identify use cases from a narrative.*

---

##### Definition:

A **use case** is a representation of an interaction between a user (often referred to as an "actor") and a system, describing a sequence of events that occur when the actor uses the system to achieve a specific goal. It provides a detailed, step-by-step description of how the system will behave in a particular scenario.

##### Components of a Use Case:

1. **Title**: A brief, descriptive name for the use case.
2. **Actor**: The user or external system that interacts with the system in the use case.
3. **Preconditions**: Conditions that must be true before the use case can start.
4. **Postconditions**: The state of the system once the use case is completed.
5. **Main Flow (Happy Path)**: A step-by-step description of the normal scenario of the use case.
6. **Alternate Flows**: Descriptions of alternative sequences that might occur, often due to exceptions or variations in the main flow.
7. **Exceptions**: Unexpected events or errors that might occur during the execution of the use case.

##### Identifying Use Cases from a Narrative:

To identify use cases from a narrative or description:

1. Look for goals or tasks that users (actors) want to achieve with the system.
2. Identify the primary activities or processes described in the narrative.
3. Recognize patterns of interaction between users and the system.
4. Pay attention to any exceptions or alternative scenarios mentioned.

**Example Narrative**:
"In the library system, members can search for books, reserve books, and check out books. Librarians can add new books and manage member accounts."

**Potential Use Cases**:
1. Search for a Book
2. Reserve a Book
3. Check Out a Book
4. Add a New Book
5. Manage Member Account

In practice, a detailed use case would further break down each of these activities into a series of steps, describing the interaction between the actor and the system.

---

### 2. *Know the various techniques that we use to identify use cases: User Goal technique and event decomposition technique, supplemented by the CRUD technique.*

---

##### User Goal Technique:

This technique focuses on the goals or objectives that users aim to achieve when interacting with a system.

- **Steps**:
    1. Identify all potential users (actors) of the system.
    2. For each user, list their goals or tasks they wish to accomplish using the system.
    3. Each goal typically translates into a use case.

- **Example**:
    For a banking system:
    - **User**: Customer
    - **Goals**: Check account balance, transfer money, pay bills.
    - **Use Cases**: "Check Account Balance", "Transfer Money", "Pay Bills".

##### Event Decomposition Technique:

This technique is based on identifying system events and then defining use cases in response to those events.

- **Steps**:
    1. Identify external events (e.g., a user wanting to purchase an item).
    2. Identify temporal events (e.g., monthly account statements).
    3. Identify state events (e.g., an account balance falling below a certain threshold).
    4. For each event, define a use case that represents the system's response.

- **Example**:
    For an online store:
    - **Event**: User adds an item to cart.
    - **Use Case**: "Add Item to Cart".

##### CRUD Technique:

CRUD stands for Create, Read, Update, and Delete. This technique is particularly useful for systems that manage data, ensuring that all essential data operations are covered.

- **Steps**:
    1. List down all the significant data entities in the system.
    2. For each entity, ensure there are use cases for creating, reading, updating, and deleting.

- **Example**:
    For a database managing student records:
    - **Entity**: Student Record
    - **Use Cases**: "Create Student Record", "Read Student Record", "Update Student Record", "Delete Student Record".

Using a combination of these techniques ensures a comprehensive identification of use cases, capturing user goals, system events, and essential data operations.

![](crudmatrix.png)

---

### 3. *Know the various types of events – internal (state), external, temporal and be able to identify each type given a list or a narrative.*

---

##### Types of Events:

1. **Internal (State) Events**:
    - **Description**: These events are triggered by a change in the system's internal state.
    - **Example**: In a banking system, an account balance dropping below a minimum threshold might trigger an alert or a penalty.
  
2. **External Events**:
    - **Description**: Initiated by actors or entities outside the system. They represent the system's need to respond to inputs or requests from external sources.
    - **Example**: A customer placing an order on an online store or a user clicking a button on a user interface.

3. **Temporal Events**:
    - **Description**: These events are triggered by the passage of time or by specific times or dates.
    - **Example**: A monthly report generation, or an alarm that goes off at a set time.

##### Identifying Types of Events from a Narrative:

Given a narrative, one can categorize events by looking for cues:

- **Internal (State) Events**: Look for changes within the system, such as status updates or thresholds being reached.
- **External Events**: Identify interactions that come from outside the system, like user inputs or requests.
- **Temporal Events**: Spot mentions of time-based triggers, like daily tasks, monthly updates, or yearly reviews.

**Sample Narrative**:
"Every day, the system generates a sales report. When a user places an order, the inventory is checked. If an item's stock falls below 10, a reorder alert is sent."

From this:
- **Temporal Event**: "Every day, the system generates a sales report."
- **External Event**: "When a user places an order..."
- **Internal (State) Event**: "If an item's stock falls below 10..."

Understanding and identifying these types of events ensures a comprehensive capture of system requirements and facilitates the definition of corresponding use cases.

---

### 4. *Know how to draw a Use Case Diagram. Notation is important – so make sure that your use cases are ovals, the actors are stick figures labeled by their role (e.g., clerk), and that the system boundary is drawn and labeled. Also, use cases should be named using the verb-noun format. Know that we have three types of relationships (association: between actor and use case), and <<include>> and <<extend>>. Given a narrative, be able to identify the use cases and actors and draw a use case diagram.*

---

##### Use Case Diagram Notation:

1. **Use Cases**:
    - Represented by **ovals**.
    - Named using the **verb-noun** format (e.g., "Place Order").

2. **Actors**:
    - Represented by **stick figures**.
    - Labeled by their role (e.g., "Customer", "Clerk").

3. **System Boundary**:
    - Represented by a **rectangle** that encompasses the use cases.
    - Defines the scope of the system being modeled.

##### Relationships:

1. **Association**:
    - A simple line connecting an actor to a use case.
    - Represents the interaction between the actor and the use case.

2. **<<include>>**:
    - Represents a use case that is included within another use case (a shared behavior).
    - Example: "Process Payment" might be included in both "Place Order" and "Renew Subscription" use cases.

3. **<<extend>>**:
    - Represents a use case that extends another use case, adding new behaviors or actions.
    - It is conditional and is executed under specific conditions.
    - Example: "Offer Discount" might extend "Place Order" if certain conditions are met.

##### Drawing a Use Case Diagram from a Narrative:

**Sample Narrative**:
"In an online store, customers can browse items, place orders, and view their order history. When placing an order, payment is processed. Occasionally, a discount is offered based on promotional events."

**Diagram Components**:
- **Actors**: Customer
- **Use Cases**: Browse Items, Place Order, View Order History, Process Payment, Offer Discount
- **Relationships**: 
    - Customer -> Browse Items (Association)
    - Customer -> Place Order (Association)
    - Customer -> View Order History (Association)
    - Place Order -> Process Payment (<<include>>)
    - Place Order -> Offer Discount (<<extend>>)

By understanding the notation and relationships, one can effectively translate system narratives into clear and concise Use Case Diagrams.

![](usecasedia.png)

---

## Release Planning - Estimation

### 1. *How do we estimate time for project completion in iterative development methodologies such as SCRUM? That is, prioritize backlog, size the stories in the backlog, estimate velocity, determine how many sprints are required.*

---

#### Estimating Time in SCRUM:

1. **Prioritize the Product Backlog**:
    - **Description**: Product Owner prioritizes user stories or features based on business value, dependencies, risks, and stakeholder feedback.
    - **Importance**: Ensures that the most valuable and critical features are developed first.

2. **Size the Stories in the Backlog**:
    - **Description**: The development team estimates the relative effort required for each user story. Common techniques include Planning Poker, T-shirt sizing, or Fibonacci sequence.
    - **Importance**: By understanding the relative complexity or effort of stories, the team can better plan sprints.

3. **Estimate Team Velocity**:
    - **Description**: Velocity is an estimate of the amount of work the team can handle in one sprint. It's often based on the average points completed in previous sprints.
    - **Importance**: Velocity helps in forecasting how much work the team can complete in future sprints.

4. **Determine the Number of Sprints Required**:
    - **Description**: Divide the total number of story points in the prioritized backlog by the estimated team velocity. This gives the number of sprints required to complete the work.
    - **Example**: If the total story points in the backlog are 100 and the team's average velocity is 20 points per sprint, you would need 5 sprints to complete the backlog.
    - **Importance**: Provides a rough estimate of the time required for project completion.

#### Considerations:

- **Changing Velocity**: Team velocity might change over time based on team dynamics, changes in team size, or the complexity of the work.
- **Emergent Work**: New work might emerge or priorities might shift as the project progresses, potentially impacting the initial estimate.
- **Feedback Loops**: Iterative methodologies like SCRUM value feedback. Changes based on client or stakeholder feedback can influence the number of sprints required.

Estimating time in SCRUM is not about exact predictions but about creating a flexible forecast that can adapt to changes and provide a general direction for the project.

---

### 2. *How do we size stories on the backlog (various techniques)? What do story points measure?*

---

#### Sizing Stories on the Backlog:

Sizing, or estimating the relative effort of stories, is a crucial aspect of backlog management. Here are some commonly used techniques:

1. **Planning Poker (or Scrum Poker)**:
    - **Description**: Team members use a set of cards with values (often Fibonacci numbers like 1, 2, 3, 5, 8, 13, etc.) to vote on the size of a user story. Discussions ensue until a consensus is reached.
    - **Advantages**: Promotes team discussion and consensus. Helps uncover different perspectives.

2. **T-Shirt Sizing**:
    - **Description**: User stories are categorized into sizes that correspond to t-shirt sizes (XS, S, M, L, XL).
    - **Advantages**: Provides a simple, non-numeric way to gauge size. Useful in early stages of planning.

3. **Dot Voting**:
    - **Description**: Each team member gets a set number of dots (or votes) they can allocate to stories based on perceived effort or complexity. The stories with the most dots are deemed the largest.
    - **Advantages**: Engages the entire team. Can be a quick way to identify complex stories.

4. **Affinity Estimation**:
    - **Description**: User stories are grouped by similarity in size. Teams discuss and compare stories to place them in the right category.
    - **Advantages**: Facilitates collaborative discussions. Useful for sizing a large number of stories quickly.

5. **Triangulation**:
    - **Description**: Comparing a new story against two previously sized stories, one that's smaller and one that's larger. This helps place the new story in relative terms.
    - **Advantages**: Helps achieve more consistent sizing by using known references.

6. **Disaggregation**:
    - **Description**: Breaking down a large or complex story into smaller, more manageable pieces. Each smaller story is then sized individually.
    - **Advantages**: Increases the accuracy of estimates by focusing on more granular tasks.

7. **Analogy**:
    - **Description**: Comparing a new story to a similar one that has been sized previously. If the new story is perceived as twice as complex as the reference, it would be given twice the points.
    - **Advantages**: Leverages past experience and knowledge for more accurate estimates.

#### What Do Story Points Measure?

**Story Points** are a unit of measure used to estimate the relative effort or complexity of a user story compared to other stories. They do not directly represent a specific duration of time but rather provide a relative scale.

Story points consider:
- **Complexity**: How intricate is the story?
- **Effort**: How much work is required to complete the story?
- **Uncertainty**: Are there unknowns or aspects of the story that could affect its completion?

The primary value of using story points is that they abstract away from time-based estimates, which can vary based on individual skills, tools, or unforeseen challenges. By focusing on relative effort and complexity, teams can achieve more consistent and collaborative estimates.

---

### 3. *What is velocity and how do we estimate it if teams (a) have worked before together; and (b) have never worked together before?*

---

#### Velocity:

**Velocity** is a metric used in Agile methodologies, particularly in Scrum, to measure the amount of work a team can complete in a single sprint. It's typically expressed in terms of "story points" or "work units" completed per sprint.

#### Estimating Velocity:

1. **For Teams That Have Worked Together Before**:
    - **Historical Data**: The most accurate way to determine velocity is by looking at the average number of story points the team has completed in previous sprints. 
    - **Steps**:
        1. Gather data from the last 3-5 sprints (or more if available).
        2. Calculate the average story points completed per sprint.
    - **Advantages**: Relies on actual performance metrics, making it more accurate and reliable.
    - **Considerations**: It's essential to consider any significant changes in team composition, tools, or working conditions that might affect future performance.

2. **For Teams That Have Never Worked Together Before**:
    - **Estimation**:
        - **Conservative Estimates**: Start with a conservative estimate, perhaps based on the performance of similar teams or industry benchmarks.
        - **Pilot Sprint**: Conduct an initial sprint without setting a strict story point goal. Use the results from this sprint to gauge future velocity.
    - **Adjustment**: It's crucial to understand that the initial sprints might not be perfectly indicative of the team's eventual steady-state velocity. As the team gels and processes are refined, velocity will likely change.
    - **Advantages**: Provides a starting point for new teams.
    - **Considerations**: Initial estimates might be off, so it's essential to be flexible and adjust plans based on actual performance in the first few sprints.

In both scenarios, it's crucial to treat velocity as a guide and not a strict target. Velocity can vary from sprint to sprint based on the nature of the work, team dynamics, and external factors.

---

### 4. *How do we determine number of sprints or iterations?*

---

#### Determining the Number of Sprints or Iterations:

1. **Total Work Estimate**:
    - Begin by estimating the total amount of work required for the project. This is typically done by sizing each user story or feature in the product backlog and summing up the story points or work units.

2. **Team's Velocity**:
    - Use the team's estimated velocity (story points or work units per sprint) to gauge how much work the team can complete in a single sprint. If the team has a track record, use the average velocity from previous sprints. For new teams, an initial estimate or the results from a pilot sprint can be used.

3. **Calculation**:
    - Divide the total work estimate by the team's velocity to determine the number of sprints required.
    - **Formula**: 
    \[
    \text{Number of Sprints} = \frac{\text{Total Work Estimate (story points)}}{\text{Team's Velocity (story points per sprint)}}
    \]

4. **Buffer or Contingency**:
    - It's a good practice to add a buffer or contingency, considering potential risks, changes in scope, or unforeseen impediments. An additional sprint or a percentage-based buffer can be added based on the project's complexity and uncertainty.

5. **Review and Adjust**:
    - As the project progresses, the initial estimates might need adjustments. Regularly review the remaining work, the team's actual velocity, and adjust the number of sprints as necessary.

#### Considerations:

- **Scope Changes**: If the project scope changes or new features are added to the backlog, the number of required sprints might increase.
- **Team Dynamics**: Factors like team size, skill level, or changes in team composition can influence velocity and, subsequently, the number of sprints.
- **External Factors**: Holidays, other organizational priorities, or external dependencies might affect the project timeline.

Remember, Agile methodologies emphasize flexibility and responsiveness to change. While initial planning is essential, it's equally crucial to adapt based on actual progress and changing requirements.

---
---
---

# Chapter 4 - Domain Class Modeling

### 1. *Given a case description, know how to draw a domain class diagram. Notation is important. Classes and their attributes need to be represented appropriately and so do the multiplicities of association relationships between two classes. Note that methods are not included in the domain classes. You need to know how to represent generalization/specialization relationships and whole/part relationships (both aggregation and composition). Given a narrative, be able to draw the domain class diagram.*

---

#### Domain Class Diagram Notation:

1. **Classes**:
    - Represented by a rectangle with the class name.
    - Below the class name, list the class attributes.
    - Note: In domain class diagrams, methods are typically not included.

2. **Association Relationships**:
    - Represented by a simple line connecting two classes.
    - Multiplicities (indicating how many instances of one class relate to instances of another class) are added at both ends of the line. Examples: `0..1`, `1`, `0..*`.

3. **Generalization/Specialization Relationships (Inheritance)**:
    - Represented by a triangle pointing to the base class (or superclass) with a line connecting it to the derived class (or subclass).
    - This indicates that the subclass is a type of the superclass.

4. **Whole/Part Relationships**:
    - **Aggregation**: Represents a "whole-part" relationship but without strong ownership. Denoted by a diamond shape at the end of the line pointing to the "whole" class.
    - **Composition**: Represents a "whole-part" relationship with strong ownership (if the "whole" is destroyed, so is the "part"). Denoted by a filled diamond shape at the end of the line pointing to the "whole" class.

#### Drawing a Domain Class Diagram from a Narrative:

**Sample Narrative**:
"In an organization, there are multiple employees. Each employee belongs to a department. A department has one or more projects. Every project is managed by an employee who assumes the role of a project manager. Furthermore, a project can have multiple tasks. Each task is assigned to an employee, and an employee can work on multiple tasks."

**Diagram Components**:
- **Classes**: Organization, Employee, Department, Project, Task.
- **Attributes**: 
    - Organization: Name
    - Employee: EmployeeID, Name
    - Department: DeptName, Location
    - Project: ProjectName, Budget
    - Task: TaskID, Description
- **Relationships**:
    - Organization to Employee: Aggregation (one organization has many employees).
    - Employee to Department: Association (one employee belongs to one department).
    - Department to Project: Composition (one department has many projects).
    - Project to Employee (as Project Manager): Association (one project is managed by one employee).
    - Project to Task: Composition (one project has many tasks).
    - Employee to Task: Association (an employee is assigned to multiple tasks and a task is assigned to one employee).

![](domainclass.png)

---

### 2. *Know terminology-multiplicity, generalization/specialization relationship, and whole/part relationship, association relationship. Be able to define each.*

---

#### Terminology:

1. **Multiplicity**:
    - **Definition**: Indicates how many instances of one class relate to instances of another class in an association relationship. Multiplicity specifies the range of allowable occurrences within the relationship.
    - **Examples**:
        - `0..1`: Zero or one instance.
        - `1`: Exactly one instance.
        - `0..*` or `*`: Zero or more instances.
        - `1..*`: One or more instances.

2. **Generalization/Specialization Relationship (Inheritance)**:
    - **Definition**: Represents an "is-a" relationship between a more general class (superclass or base class) and a more specific class (subclass or derived class). The derived class inherits attributes and operations from the base class.
    - **Example**: If "Bird" is a general class, "Sparrow" and "Penguin" could be specialized classes. A Sparrow "is-a" Bird.

3. **Whole/Part Relationship**:
    - **Aggregation**:
        - **Definition**: Represents a "whole-part" relationship but without strong ownership. The "part" can exist independently of the "whole".
        - **Example**: A "Department" (whole) has "Employees" (part), but an employee can exist without a department.
    - **Composition**:
        - **Definition**: Represents a "whole-part" relationship with strong ownership. The "part" cannot exist without the "whole". If the "whole" is destroyed, so is the "part".
        - **Example**: An "Order" (whole) consists of "OrderLines" (parts). If the order is deleted, its associated order lines are also deleted.

4. **Association Relationship**:
    - **Definition**: Represents a bi-directional relationship between two classes. It indicates that objects of one class are somehow related to objects of another class. 
    - **Example**: A "Teacher" teaches a "Course". Here, "teaches" is the association between the "Teacher" and "Course" classes.

---

### 3. *Know the two techniques that can be used to identify “things” in the problem domain that can help you develop your domain class diagrams: the brainstorming technique and the noun technique.*

---

#### Techniques to Identify “Things” in the Problem Domain:

1. **Brainstorming Technique**:
    - **Definition**: A collaborative approach where team members come together to freely and spontaneously generate ideas and identify potential entities or "things" in the problem domain.
    - **Steps**:
        1. Gather a cross-functional team, including stakeholders, domain experts, developers, and analysts.
        2. Present the problem domain or use-case scenarios.
        3. Allow team members to freely suggest potential entities, relationships, attributes, etc.
        4. Capture all ideas without immediate judgment.
        5. Refine and consolidate the list, removing duplicates or merging similar ideas.
    - **Advantages**: Encourages diverse perspectives, can uncover hidden or overlooked entities, and promotes team collaboration.

2. **Noun Technique**:
    - **Definition**: A systematic approach to identify entities or "things" by examining documentation, requirements, or narratives and picking out the nouns as potential classes for the domain class diagram.
    - **Steps**:
        1. Obtain a descriptive narrative or documentation of the problem domain.
        2. Highlight or list down all the nouns present in the text.
        3. Evaluate each noun to determine if it represents a potential class or entity in the domain. Not all nouns will be relevant; some might be redundant or too granular.
        4. For each identified noun or entity, consider its potential attributes and relationships.
    - **Advantages**: Provides a structured method to dissect requirements or narratives, ensuring a thorough examination of the problem domain.

---

### 4. *State Machine Diagrams: Know when and why we need to develop state machine diagrams. Be able to identify objects for which we need to develop a state machine diagram. Be able to draw one given a scenario. Know proper notation. You will not have to draw composite states – just know what they are.*

---

#### State Machine Diagrams:

1. **Purpose**:
    - **Definition**: State Machine Diagrams depict the lifecycle of an object, showing the different states an object can be in and the transitions between those states.
    - **Why Use Them**: They are useful to model the behavior of an object throughout its lifecycle, especially when the object's behavior is complex or has many conditional scenarios.

2. **When to Develop**:
    - For objects with complex lifecycles.
    - When there are specific actions or events that trigger state changes.
    - To represent conditional or branching behaviors based on events or conditions.
    - When understanding an object's behavior is crucial to the system's functionality.

3. **Identifying Objects for State Machine Diagrams**:
    - Objects that undergo various states during their lifecycle.
    - Objects whose states are affected by specific events or conditions.
    - Examples: Order (Created, Processed, Shipped, Delivered), User Account (Active, Suspended, Closed).

4. **Notation**:
    - **States**: Represented by rounded rectangles. The state name is inside the rectangle.
    - **Transitions**: Represented by arrows between states. The event or trigger causing the transition can be labeled on the arrow.
    - **Start State**: Represented by a filled circle.
    - **End State**: Represented by a filled circle inside a larger circle.
    - **Guard Conditions**: Conditions that must be true for a transition to occur, depicted in square brackets near the transition arrow. For example: `[Payment Received]`.
    - **Actions**: Specific actions that occur either in a state or during a transition. For example: `/Send Notification`.

5. **Composite States**:
    - **Definition**: States that have sub-states or nested states within them. They are used to simplify complex state diagrams by grouping related states into a higher-level state.
    - **Recognition**: They are depicted as a larger rectangle containing the nested sub-states.
    - **Usage**: While you won't have to draw them, recognize that they help in organizing and simplifying state diagrams by encapsulating related behaviors.

Given a scenario, the key is to identify the primary object, its possible states, the events that trigger state transitions, and any conditions or actions associated with states or transitions.

---
---
---

# Chapter 5 - Extending Requirements

### 1. *Use Case Description: Need to understand trigger, actors, stakeholders, pre-conditions and post- conditions (make sure you link many of these to your domain class diagram), flow of activities (make sure these are detailed and appropriately numbered; that they take the form “1. the user does something:”; “1.1. the system does something”; use if statements where appropriate; use loops [e.g., repeat steps 1-3 as long as the user adds more items to the cart]) and exceptions (make sure these are appropriately numbered based on the step in the flow of activities at which they occur and that they describe what happens if the exception occurs). Also remember that we assume “perfect technology conditions” when we are developing our use case descriptions, activity diagrams, and system sequence diagrams.*

---

#### Use Case Description:

A Use Case Description provides a detailed account of a system's interaction with its actors, specifying how the system behaves under various conditions.

**Components**:

1. **Trigger**:
    - Describes the event that initiates the use case. 
    - Example: A user clicking the "Checkout" button on an e-commerce website.

2. **Actors**:
    - Entities that interact with the system. Can be primary (initiating the interaction) or secondary (providing a service to the system).
    - Example: User, Payment Gateway.

3. **Stakeholders**:
    - Individuals or groups who have an interest in the execution of the use case but may not interact directly.
    - Example: Store Manager interested in successful sales.

4. **Pre-conditions**:
    - The conditions that must be true before the use case can start.
    - Example: User must have items in the cart.

5. **Post-conditions**:
    - The conditions that will be true after the use case has been executed successfully.
    - Example: Order is placed, and inventory is updated.

6. **Flow of Activities**:
    - Sequential steps detailing the interactions between the actor and the system.
    - Structured as:
        - "1. The user does something."
        - "1.1. The system responds."
        - Use "if" statements for conditional actions.
        - Use loops like "repeat steps 1-3 as long as the user adds more items to the cart."

7. **Exceptions**:
    - Describes scenarios where things don't go as planned in the main flow. They should be numbered based on the step in the flow of activities where they occur.
    - Example: "2.1. If payment fails, notify the user."

**Linking to Domain Class Diagram**:
- Ensure that entities and actions mentioned in the Use Case Description are consistent with the Domain Class Diagram. For instance, if the use case involves a "User" making an "Order", both "User" and "Order" should be identifiable in the Domain Class Diagram.

**Assumption of Perfect Technology Conditions**:
- When developing use case descriptions, activity diagrams, and system sequence diagrams, assume that the underlying technology functions flawlessly. Focus on the business logic and user interactions rather than potential technological failures.

![](usecasedesc.png)
![](usecasedesc2.png)

---

### 2. *Activity Diagram: Using the flow of activities in the use case description, develop the activity diagram. Remember, the activity diagram needs to mirror the flow of activities in the use case description (and exceptions). Also, remember that we typically have 2 swim lanes – one for the user and one for the system. These are typically shown vertically. Use proper notation.*

--- 

#### Activity Diagram:

An Activity Diagram visually represents the flow of control from activity to activity in a system, effectively mapping out the sequential and parallel activities in a process.

**Steps to Develop**:

1. **Swim Lanes**:
    - Start by drawing two vertical swim lanes, typically labeled "User" and "System". Swim lanes help in organizing and categorizing the actions based on the actor responsible.

2. **Start and End Nodes**:
    - Use a filled circle to represent the start node.
    - Use a filled circle inside a larger circle to denote the end node.

3. **Activities**:
    - Translate each step in the flow of activities from the Use Case Description into an activity in the diagram.
    - Use rounded rectangles to represent activities.

4. **Transitions**:
    - Arrows indicate the flow from one activity to the next.

5. **Decision Nodes**:
    - Represented by diamonds, these are used when there are conditional flows (like "if" statements in the Use Case Description).
    - Each outgoing arrow from a decision node should represent a possible outcome (e.g., "yes" or "no").

6. **Parallel Activities**:
    - Use a synchronization bar (a horizontal or vertical bar) to represent the start or end of concurrent activities.

7. **Exceptions**:
    - Integrate exceptions from the Use Case Description, connecting them appropriately to the activity they relate to. You can use decision nodes or annotations to indicate the exception conditions.

**Tips**:

- Ensure consistency between the Use Case Description and the Activity Diagram. Every step in the Use Case should have a corresponding element in the diagram.
- Use clear and concise labels for activities to make the diagram easily understandable.
- If the diagram becomes too large or complex, consider breaking it down into smaller, more focused diagrams or using sub-activities.

**Example**:

Imagine a Use Case Description where:
1. A user submits a login form.
2. The system validates the credentials.
3. If valid, the system grants access.
4. If invalid, the system denies access.

In the Activity Diagram:
- "User" swim lane will have the activity "Submit login form".
- "System" swim lane will have the activities "Validate credentials", "Grant access", and "Deny access".
- A decision node after "Validate credentials" will direct the flow either to "Grant access" or "Deny access" based on validity.

![](actdia.png)

---

### 3. *System Sequence Diagrams: Remember that the objective of these is to show the interaction (in terms of inputs and outputs and messages) between the actor and the system. Again, the messages passed between user and system should mirror very closely the flow of activities in the use case description. Use proper notation (including loops, conditional execution, etc.)– and make sure you clearly show the exact inputs the user provides to the system and the outputs the system provides back – consult the domain class diagram for attributes. Also remember that in sequence diagrams the lines are time ordered from top to bottom.*

---

#### System Sequence Diagrams (SSDs):

SSDs illustrate the interactions between external actors and a system, focusing on the sequence of messages exchanged.

**Objective**:
- Show the interaction in terms of inputs, outputs, and messages between the actor and the system.
- Clearly depict the time-ordered sequence of these interactions.

**Steps to Develop**:

1. **Actors and System**:
    - Draw the actor (usually on the left) and the system (on the right) as vertical lifelines.

2. **Messages**:
    - Represented by horizontal arrows between the actor and system lifelines.
    - The direction of the arrow indicates the message's direction: from actor to system or vice versa.

3. **Time Ordering**:
    - Messages are time-ordered from top to bottom. The topmost message occurs first, and the bottommost message occurs last.

4. **Inputs and Outputs**:
    - Clearly label messages with the exact inputs the user provides to the system and the outputs the system provides back.
    - Consult the Domain Class Diagram for attributes when labeling these messages.

5. **Loops**:
    - If a message or set of messages repeats, represent this with a loop. Use a rectangular frame labeled `loop` and a condition (e.g., `while items remain`).

6. **Conditional Execution**:
    - Represent conditional messages using an `alt` frame. Divide the frame into segments for each condition, labeling each with its condition (e.g., `if valid` and `else`).

7. **Return Messages**:
    - Often, after the system receives a message, it sends a response back to the actor. Represent this with a dashed arrow pointing back to the actor.

**Example**:

Imagine a Use Case Description for user login:
1. User submits credentials.
2. System validates credentials.
3. If valid, the system grants access.
4. If invalid, the system shows an error message.

In the SSD:
- Actor (User) sends a `Submit Credentials` message to the System.
- System sends back either a `Grant Access` message or an `Error` message based on validation.

![](sqncedia.png)

---